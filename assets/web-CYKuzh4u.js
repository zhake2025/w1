import{W as S}from"./index-Bp4oiTTd.js";const{Client:x}=require("@modelcontextprotocol/sdk/client/index.js"),{SSEClientTransport:m}=require("@modelcontextprotocol/sdk/client/sse.js");class E extends S{constructor(){super(),this.sseConnections=new Map,this.wsConnections=new Map,this.mcpClients=new Map,this.mcpTransports=new Map,this.connectionCounter=0,this.proxyServerUrl=null,this.detectProxyServer()}async detectProxyServer(){const n=["http://localhost:3002","http://127.0.0.1:3002","http://localhost:3001","http://127.0.0.1:3001","http://localhost:8080","http://127.0.0.1:8080"];for(const t of n)try{const e=new AbortController,s=setTimeout(()=>e.abort(),1e3),i=await fetch(`${t}/health`,{method:"GET",signal:e.signal});if(clearTimeout(s),i.ok){this.proxyServerUrl=t,console.log(`üîß CORS Proxy server detected at: ${t}`);break}}catch{}this.proxyServerUrl||(console.warn("‚ö†Ô∏è No CORS proxy server detected. Some requests may fail due to CORS."),console.log("üí° To enable full functionality, run: node web-proxy-server.js"))}setProxyServer(n){this.proxyServerUrl=n,console.log(`üîß Proxy server set to: ${n}`)}async request(n){const{url:t,method:e="GET",headers:s={},data:i,params:d,timeout:u=3e4,responseType:l="json",followRedirects:o=!0}=n;let c=t;if(d){const r=new URLSearchParams(d);c+=(t.includes("?")?"&":"?")+r.toString()}let a=c,C={method:e,headers:s,redirect:o?"follow":"manual"};this.proxyServerUrl&&this.isCrossOrigin(c)&&(console.log(`üîß Using proxy server for: ${c}`),a=`${this.proxyServerUrl}/proxy/${encodeURIComponent(c)}`);const p=new AbortController,h=setTimeout(()=>p.abort(),u);C.signal=p.signal;try{i&&["POST","PUT","PATCH"].includes(e)&&(typeof i=="string"?C.body=i:(C.body=JSON.stringify(i),s["Content-Type"]||(s["Content-Type"]="application/json")));const r=await fetch(a,C);clearTimeout(h);let y;switch(l){case"text":y=await r.text();break;case"blob":y=await r.blob();break;case"arraybuffer":y=await r.arrayBuffer();break;case"json":default:try{y=await r.json()}catch{y=await r.text()}break}const w={};return r.headers.forEach((f,g)=>{w[g]=f}),{status:r.status,statusText:r.statusText,headers:w,data:y,url:r.url}}catch(r){if(clearTimeout(h),this.proxyServerUrl&&a.includes(this.proxyServerUrl))return console.warn(`‚ö†Ô∏è Proxy request failed, trying direct request: ${r}`),this.request({...n,url:c});throw r}}async get(n){return this.request({...n,method:"GET"})}async post(n){return this.request({...n,method:"POST"})}async put(n){return this.request({...n,method:"PUT"})}async patch(n){return this.request({...n,method:"PATCH"})}async delete(n){return this.request({...n,method:"DELETE"})}async startSSE(n){const t=`sse_${++this.connectionCounter}`,{url:e,headers:s={},withCredentials:i=!1,reconnectTimeout:d=3e3}=n;let u=e;this.proxyServerUrl&&this.isCrossOrigin(e)&&(console.log(`üîß Using SSE proxy for: ${e}`),u=`${this.proxyServerUrl}/sse-proxy/${encodeURIComponent(e)}`);const l=new EventSource(u);return this.sseConnections.set(t,l),l.onopen=()=>{this.notifyListeners("sseOpen",{connectionId:t,status:"connected"})},l.onmessage=o=>{this.notifyListeners("sseMessage",{connectionId:t,type:"message",data:o.data,id:o.lastEventId})},l.onerror=()=>{this.notifyListeners("sseError",{connectionId:t,error:"Connection error"})},{connectionId:t}}async stopSSE(n){const{connectionId:t}=n,e=this.sseConnections.get(t);e&&(e.close(),this.sseConnections.delete(t),this.notifyListeners("sseClose",{connectionId:t,status:"disconnected"}))}isCrossOrigin(n){try{const t=new URL(n),e=new URL(window.location.href);return t.origin!==e.origin}catch{return!1}}async createSSEConnection(n){const t=`sse_${++this.connectionCounter}`,{url:e,headers:s={},reconnect:i={}}=n,{enabled:d=!0,initialDelay:u=1e3,maxDelay:l=3e4,maxAttempts:o=10}=i;let c=0,a=u;const C=()=>{let p=e;this.proxyServerUrl&&this.isCrossOrigin(e)&&(console.log(`üîß Using SSE proxy for: ${e}`),p=`${this.proxyServerUrl}/sse-proxy/${encodeURIComponent(e)}`);const h=new EventSource(p);this.sseConnections.set(t,h),h.onopen=()=>{c=0,a=u,this.notifyListeners("sseConnectionChange",{connectionId:t,status:"connected"})},h.onmessage=r=>{this.notifyListeners("sseMessage",{connectionId:t,type:"message",data:r.data,id:r.lastEventId})},h.onerror=()=>{this.notifyListeners("sseConnectionChange",{connectionId:t,status:"error",error:"Connection error"}),d&&c<o?setTimeout(()=>{c++,a=Math.min(a*2,l),h.close(),C()},a):this.sseConnections.delete(t)},h.addEventListener("error",r=>{this.notifyListeners("sseMessage",{connectionId:t,type:"error",data:"Connection error"})})};return this.notifyListeners("sseConnectionChange",{connectionId:t,status:"connecting"}),C(),{connectionId:t,status:"connecting"}}async closeSSEConnection(n){const{connectionId:t}=n,e=this.sseConnections.get(t);e&&(e.close(),this.sseConnections.delete(t),this.notifyListeners("sseConnectionChange",{connectionId:t,status:"disconnected"}))}async createWebSocketConnection(n){const t=`ws_${++this.connectionCounter}`,{url:e,protocols:s,headers:i,timeout:d=1e4}=n;return new Promise((u,l)=>{const o=new WebSocket(e,s);this.wsConnections.set(t,o);const c=setTimeout(()=>{o.close(),this.wsConnections.delete(t),l(new Error("WebSocket connection timeout"))},d);o.onopen=()=>{clearTimeout(c),this.notifyListeners("webSocketConnectionChange",{connectionId:t,status:"connected"}),u({connectionId:t,status:"connected"})},o.onmessage=a=>{this.notifyListeners("webSocketMessage",{connectionId:t,data:a.data,type:typeof a.data=="string"?"text":"binary"})},o.onerror=()=>{clearTimeout(c),this.notifyListeners("webSocketConnectionChange",{connectionId:t,status:"error",error:"WebSocket connection error"})},o.onclose=()=>{this.wsConnections.delete(t),this.notifyListeners("webSocketConnectionChange",{connectionId:t,status:"disconnected"})},this.notifyListeners("webSocketConnectionChange",{connectionId:t,status:"connecting"})})}async closeWebSocketConnection(n){const{connectionId:t}=n,e=this.wsConnections.get(t);e&&(e.close(),this.wsConnections.delete(t))}async sendWebSocketMessage(n){const{connectionId:t,message:e}=n,s=this.wsConnections.get(t);if(s&&s.readyState===WebSocket.OPEN)s.send(e);else throw new Error("WebSocket connection not found or not open")}async createMCPClient(n){const t=`mcp_${++this.connectionCounter}`;try{let e;if(this.proxyServerUrl&&this.isCrossOrigin(n.sseUrl)){const i=`${this.proxyServerUrl}/sse-proxy/${encodeURIComponent(n.sseUrl)}`;e=new m(new URL(i))}else e=new m(new URL(n.sseUrl));const s=new x({name:n.clientInfo.name,version:n.clientInfo.version},{capabilities:{roots:n.capabilities?.roots?{listChanged:!0}:void 0,sampling:n.capabilities?.sampling?{}:void 0}});return await s.connect(e),this.mcpClients.set(t,s),this.mcpTransports.set(t,e),console.log(`‚úÖ MCPÂÆ¢Êà∑Á´ØÂ∑≤ËøûÊé•: ${t}`),{connectionId:t,status:"connected",serverCapabilities:s.getServerCapabilities(),protocolVersion:"2025-03-26"}}catch(e){throw console.error("‚ùå MCPÂÆ¢Êà∑Á´ØËøûÊé•Â§±Ë¥•:",e),new Error(`Failed to create MCP client: ${e}`)}}async listMCPResources(n){const t=this.mcpClients.get(n.connectionId);if(!t)throw new Error("MCP client not found");try{const e=await t.listResources(n.cursor?{cursor:n.cursor}:{});return{resources:e.resources||[],nextCursor:e.nextCursor}}catch(e){throw new Error(`Failed to list MCP resources: ${e}`)}}async readMCPResource(n){const t=this.mcpClients.get(n.connectionId);if(!t)throw new Error("MCP client not found");try{const e=await t.readResource({uri:n.uri});return{uri:n.uri,mimeType:e.contents?.[0]?.mimeType||"text/plain",text:e.contents?.[0]?.text||"",blob:e.contents?.[0]?.data}}catch(e){throw new Error(`Failed to read MCP resource: ${e}`)}}async listMCPTools(n){const t=this.mcpClients.get(n.connectionId);if(!t)throw new Error("MCP client not found");try{const e=await t.listTools(n.cursor?{cursor:n.cursor}:{});return{tools:e.tools||[],nextCursor:e.nextCursor}}catch(e){throw new Error(`Failed to list MCP tools: ${e}`)}}async callMCPTool(n){const t=this.mcpClients.get(n.connectionId);if(!t)throw new Error("MCP client not found");try{const e=await t.callTool({name:n.name,arguments:n.arguments||{}});return{content:e.content||[],isError:e.isError||!1}}catch(e){throw new Error(`Failed to call MCP tool: ${e}`)}}async listMCPPrompts(n){const t=this.mcpClients.get(n.connectionId);if(!t)throw new Error("MCP client not found");try{const e=await t.listPrompts(n.cursor?{cursor:n.cursor}:{});return{prompts:e.prompts||[],nextCursor:e.nextCursor}}catch(e){throw new Error(`Failed to list MCP prompts: ${e}`)}}async getMCPPrompt(n){const t=this.mcpClients.get(n.connectionId);if(!t)throw new Error("MCP client not found");try{const e=await t.getPrompt({name:n.name,arguments:n.arguments||{}});return{description:e.description||"",messages:e.messages||[]}}catch(e){throw new Error(`Failed to get MCP prompt: ${e}`)}}async sendMCPSampling(n){throw new Error("MCP sampling not yet implemented with SDK")}}export{E as CorsBypassWeb};
